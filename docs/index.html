<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://fonts.googleapis.com/css?family=Roboto:400,700" rel="stylesheet">
    <meta charset="utf-8">
    <title>Truchet.js</title>
  </head>
  <body>
    <h2 id="truchet-tiles">Truchet Tiles</h2>
<p>Truchet tiles are square tiles decorated in such a way that when they are placed in a random orientation on a plane, they create visually appealing patterns.</p>
<p><strong>Truchet.js</strong> is a small library aimed at simplifying the creation of these visual patterns in an environment where the canvas size is unknown (i.e the web). Truchet.js is not a tool for creating patterns, but rather a tool for applying these patterns on a given canvas, and updating it when applicable if it&#39;s dimensions change.</p>
<p>But enough talking, let&#39;s get started!</p>
<h2 id="installation">Installation</h2>
<h4 id="npm">NPM</h4>
<p>Install with <a href="https://www.npmjs.com/">npm</a>, or <a href="https://yarnpkg.com/">Yarn</a>:</p>
<pre><code class="language-sh">npm i truchet --save</code></pre><p>Use with <a href="https://nodejs.org/en/">Node.js</a>, or <a href="https://webpack.github.io/">webpack</a>:</p>
<pre><code class="language-js">const Truchet = require(&apos;truchet&apos;);</code></pre><p>Or, if you are using ES6:</p>
<pre><code class="language-js">import Truchet from &apos;truchet&apos;;</code></pre><h4 id="cdn">CDN</h4>
<p>Alternatively you can add a <code>&lt;script&gt;</code> tag in your document&#39;s head, and it will export a global <code>Truchet</code> class:</p>
<pre><code class="language-js">&lt;script src=&quot;https://unpkg.com/truchet@latest/truchet.min.js&quot;&gt;&lt;/script&gt;</code></pre><h2 id="magical-patterns">Magical Patterns</h2>
<p>The first thing you need to do is create a tile that is asymmetric, so that it has more than one orientation. You can use any HTML element that you like, but in the next examples
we&#39;ll be using SVG.</p>
<p>You can use a library like <a href="https://svgjs.com/">SVG.js</a>, but for our purpose, a simple utility function will suffice:</p>
<pre><code class="language-js">// A function for creating SVG elements
const createNode = (n, v = {}) =&gt; {
    n = document.createElementNS(&quot;http://www.w3.org/2000/svg&quot;, n);
    Object.keys(v).forEach(p =&gt; {
        n.setAttributeNS(null, p, v[p]);
    })
    return n;
}</code></pre><p>The <code>Truchet</code> instance expects a DOM element as its first argument in which it will render the tiles. In our case, it should be an <code>&lt;svg/&gt;</code> element.
The 2nd &amp; 3rd argument are the tile <strong>width</strong> &amp; <strong>height</strong> respectively.</p>
<pre><code class="language-js">const size = 100;
const target = document.getElementById(&apos;target&apos;); // Our SVG element
const truchet = new Truchet(target, size, size});</code></pre><p>Now let&#39;s create a tile. Our tile will consist of 2 arcs that begin and end at the center of 2 adjacent edges, and will have a size of <code>100</code> pixels.
You can use <code>addTile(id, generator)</code> to define a new tile type. The <code>id</code> is used as a handle for this tile type, and the <code>generator</code> is a function that should
return a DOM element when called. This function receives the <code>props</code> object we pass to it from the <code>render</code> function, as we will later see.</p>
<pre><code class="language-js">truchet.addTile(&apos;a&apos;, ({x, y}) =&gt; {
    // We need to wrap our 2 paths in a &lt;g/&gt; since we can only return a single DOM element.
    const g = createNode(&apos;g&apos;);
    g.appendChild(createNode(&apos;path&apos;, {d: &apos;M 0,50 A 50,50 0 0 0 50 0&apos;}));
    g.appendChild(createNode(&apos;path&apos;, {d: &apos;M 50,100 A 50,50 0 0 1 100 50&apos;}));
    g.style.setProperty(&apos;transform-origin&apos;, `${size/2}px ${size/2}px`);
    g.style.setProperty(&apos;transform&apos;, `translate(${x}px, ${y}px)`);
    return g;
});</code></pre><p>Finally, we need to call <code>render(callback)</code> to render our pattern.<br>The <code>render</code> function receives a callback that, when called, should return a props object to be passed to your tile generator function.<br>These props are used by <strong>Truchet.js</strong> to determine whether a tile should be rendered or not.<br>To determine that, these props are shallow compared with the tile&#39;s previous props and if they are different, the tile generator function will be called and the DOM will be updated.
The only prop that is mandatory here is the <code>id</code>, which is used to pick the correspnding tile generator function.</p>
<example id="1">truchet.render((row, col) =&gt; ({
    id: &apos;a&apos;, 
    x: col * size, 
    y: row * size,
}));</example><p>This looks nice, but not very exciting. Let&#39;s add some randomness to the mix by randomly rotating the tiles.
We can do this by passing an additional prop via the <code>render</code> callback to our tile generator function:</p>
<pre><code class="language-js">truchet.addTile(&apos;a&apos;, ({x, y, rotate}) =&gt; {
    // We need to wrap our 2 paths in a &lt;g/&gt; since we can only return a single DOM element.
    const g = createNode(&apos;g&apos;);
    g.appendChild(createNode(&apos;path&apos;, {d: &apos;M 0,50 A 50,50 0 0 0 50 0&apos;}));
    g.appendChild(createNode(&apos;path&apos;, {d: &apos;M 50,100 A 50,50 0 0 1 100 50&apos;}));
    g.style.setProperty(&apos;transform-origin&apos;, `${width/2}px ${height/2}px`);
    g.style.setProperty(&apos;transform&apos;, `translate(${x}px, ${y}px) rotate(${rotate}deg)`);
    return g;
});</code></pre><p>Update the <code>render</code> function to pass a <code>rotate</code> prop:</p>
<example id="2">truchet.render((x, y) =&gt; ({
    id: &apos;a&apos;,
    rotate: [0, 90][Math.floor(Math.random() * 2)], // Randomly toggle between 0 and 90 degree rotation
    x,
    y,
}));</example>
    <script src="index.min.js"></script>
  </body>
</html>